knitr::opts_chunk$set(echo = TRUE)
rm(list = ls()) # clear the workspace
graphics.off() # close graphics windows
# opar <- par()
library(deSolve)
library(viridis)
rm(list = ls()) # clear the workspace
graphics.off() # close graphics windows
# opar <- par()
library(deSolve)
# set up the system of differential equations-----------------------------------
odeequations <- function(t, y, params){
Sp = y[1] # number of susceptible animals in pristine habitat
Ip = y[2] # number of infected animals in pristine habitat
St = y[3] # number of susceptible animals in toxicant-contaminated habitat
It = y[4] # number of infected animals in toxicant-contaminated habitat
m = params[1] # natural death rate
b0 = params[2] # max birth rate
b1 = params[3] # density-dependent birth rate
f = params[4] # proportion of toxicant-contaminated habitat
sigma = params[5] # dispersal rate between habitats
beta_p = params[6] # transmission in pristine habitat
beta_t = params[7] # transmission in toxicant-contaminated habitat
gamma = params[8] # recovery rate. 1/gamma = infectious period
mu = params[9] # infection-induced mortality
c_sigma = params[10] # movement cost induced by living in
# toxicant-contaminated habitat
c_m = params[11] # natural mortality cost induced by living in
# toxicant-contaminated habitat
alpha = params[12] # synergistic effect of infection and toxicants on survival
# differential equations which describe the system dynamics
dSpdt = (b0 - (b1*(Sp+Ip))/(1-f))*(Sp+Ip) - m*Sp - beta_p*Sp*Ip + gamma*Ip -
sigma*f*Sp + sigma*(1-c_sigma)*(1-f)*St
# dSpdt = births - natural deaths - Sp exports + recoveries
#  - infecteds + St imports
dIpdt = beta_p*Sp*Ip - gamma*Ip - (m + mu)*Ip +
sigma*(1-c_sigma)*(1-f)*It - sigma*f*Ip
# dIpdt = infecteds - recovereds - natural and infection-induced deaths
# + It imports - Ip imports
dStdt = (b0 - (b1*(St + It)/f))*(St + It) - (m/(1-c_m))*St - beta_t*St*It +
gamma*It + sigma*f*Sp - sigma*(1-c_sigma)*(1-f)*St
# dStdt = births - natural deaths (incorporating a toxicant cost) - infecteds
# + recoveries + Sp imports - St exports
dItdt = beta_t*St*It - gamma*It - ((m + mu)/(1 - alpha*c_m))*It +
sigma*f*Ip - sigma*(1-c_sigma)*(1-f)*It
# dItdt = infecteds - recoveries - deaths (with toxicant cost and multiplier)
# + Ip imports- It exports
return(list(c(dSpdt, dIpdt, dStdt, dItdt)))
}
# time for running the simulation
tmax <- 50 # max time (here, years) for which to run the integration
dt <- 0.5 # timestep at which the solution is returned
timevec = seq(0, tmax, by = dt) # creates a vector of times
# for which integration is evaluated
# (from 0 to tmax in steps of dt)
# function to run everything
contamFunc = function(beta_p = 0.006, beta_t = 0.006, mu = 1/4, c_sigma = 0.2,
c_m = 0.2, alpha = 2, I0 = 100){
fvec = seq(0.01, 0.99, by = 0.01)
odeoutput.list = vector("list", length(fvec))
equil_val <- as.data.frame(matrix(NA, nrow = length(fvec), ncol = 8))
colnames(equil_val) <- c("f", "Sp", "Ip", "St", "It", "N", "I/N", "It/f")
counter <- 1
for(i in fvec){
# assign initial values of the compartments
popSize <- 5e4
# values for model parameters, units are 1/years
m <- 1/10 # natural death rate parameter. 1/m = avg. lifespan in years
b0 <- 0.4 # per capita births per year
b1 <- (b0-m)/popSize
f <- fvec[counter] # proportion of toxicant-contaminated habitat
pstay <- 0.1 # 10% chance of not switching habitats in a year
sigma <- -log(pstay) # dispersal rate
beta_p <- beta_p # transmission in pristine habitat
beta_t <- beta_t # transmission in toxicant-contaminated habitat
gamma <- 36.5 # recovery rate. 1/gamma = infectious period
mu <- mu # infection-induced mortality
c_sigma <- c_sigma # movement cost
c_m <- c_m # natural mortality cost. if c_m = 1/2, this halves the lifespan
alpha <- alpha # synergistic effect of infection and toxicants on survival
# if alpha = 1, the costs of being infected and being in a
#    toxicant-contaminated habitat are added to each other
# if alpha > 1, there is a multiplying effect
# combines all parameters into a vector which is sent to the ODE function
parvec <- c(m, b0, b1, f, sigma, beta_p, beta_t, gamma, mu, c_sigma, c_m,
alpha)
I0 <- I0 # initial total infected
S0 <- popSize - I0 # initial total susceptible
# assign to pristine and tox-contam habitats based on habitat proportions
Sp0 <- S0*(1-f) # initial susceptible animals in pristine habitat
Ip0 <- I0*(1-f) # initial infected animals in pristine habitat
St0 <- S0*f # initial susceptible animals in toxicant-contaminated habitat
It0 <- I0*f # initial infected animals in toxicant-contaminated habitat
Y0 <- ceiling(c(Sp0, Ip0, St0, It0)) # combine init conditions into a vector
# ceiling rounds up to nearest whole #
# call ode-solver to integrate ODEs
odeoutput <- lsoda(y = Y0, times = timevec, func = odeequations,
parms = parvec)
odeoutput.df <- as.data.frame(odeoutput)
# sum number of infecteds at each time step
odeoutput.df[, 6] <- odeoutput[, 3] + odeoutput[, 5]
odeoutput.list[[counter]] <- odeoutput.df
equil_val[counter, 1] <- f
# store last row (i.e. equilibrium values) in separate matrix
equil_val[counter, 2:5] <- tail(odeoutput.df, 1)[, -c(1, 6)]
# calculate N (sum Sp, Ip, St, It)
equil_val[counter, 6] <- sum(equil_val[counter, 2:5])
# calculate proportion infected (Ip + It)/N
equil_val[counter, 7] <- sum(equil_val[counter, c(3,5)]) /
equil_val[counter, 6]
# calculate It/f, "spillover risk"
# density of infected hosts in toxicant-contaminated habitat
equil_val[counter, 8] <- equil_val[counter, 5] / equil_val[counter, 1]
counter <- counter + 1
}
return(equil_val)
}
# low movement cost scenario----------------------------------------------------
noinf <- contamFunc(I0 = 0) # no infection
equalBetas <- contamFunc(beta_t = 0.006, c_sigma = 0.2) # beta_t = beta_p
bigBetat <- contamFunc(beta_t = 0.0105, c_sigma = 0.2) # beta_t > beta_p
smallBetat <- contamFunc(beta_t = 0.0015, c_sigma = 0.2) # beta_t < beta_p
# store values of N for no disease
allDat <- noinf[, c("f", "N")]
# store N, I/N, and It/f for three values of beta_t
allDat[, 3:5] <- equalBetas[c("N", "I/N", "It/f")]
allDat[, 6:8] <- bigBetat[c("N", "I/N", "It/f")]
allDat[, 9:11] <- smallBetat[c("N", "I/N", "It/f")]
names(allDat)[2:11] <- c("N_no inf",
"N_eqBt", "I/N_eqBt", "It/f_eqBt",
"N_bigBt", "I/N_bigBt", "It/f_bigBt",
"N_smallBt", "I/N_smallBt", "It/f_smallBt")
allDat
