---
title: ""
output:
  html_document:
    toc: true
    fig_caption: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Methods
In this section the methods will be discussed. This is divided into two parts: the software and the model. The software part lists the programming language and packages that have been used, with the corresponding versions. The model section lists the differential equations. This is followed by the values and definitions of each parameter of each value is then discussed. 

The code used in this project is written used R version 4.1.3. In R the DeSolve package (version 1.32) is imported in order to model the differential equations, which are shown below. 

The model is set-up using the following differential equations:
```{r, echo=FALSE, fig.cap="caption.....", out.width = '70%'}
knitr::include_graphics("./images/ODE.png")
```
In figure 1 four differential equations are shown. Firstly, $\frac {dS_P}{dt}$ calculates the population size of the susceptible (S) flying foxes which are located in a pristine (P) area. Secondly, $\frac {dI_P}{dt}$ calculates the mount of infected (I) flying foxes in a pristine (P) area. Thirdly, $\frac {dS_T}{dt}$ calculates the amount of flying foxes which are susceptible (S) and in a toxic (T) area. Lastly, $\frac {dI_T}{dt}$ calculates the population size of the flying foxes which are infected (I) and located in a toxic area (T)

Additionally, in figure 1 parts of the differential equations are coloured. Each colour represents a different process which may affect the population size with that infection status and habitat. Green is used to indicate demography, orange to indicate infection and purple to indicate movement.
*Indicate goed woord ?*

Each equation is broken down into its parameters and listed below:
```{r, echo=FALSE, fig.cap="caption.....", out.width = '70%'}
knitr::include_graphics("./images/parameters.png")
```
As shown in figure 2;  $\beta_T$, $f$ and $c_{\sigma}$ show variating values. This is based on the different scenarios that are being modulated. In both scenarios (to be discussed shortly) $f$ is being changed, ranging from 0.01 to 0.99 (in steps of 0.01). This is the  amount of landscape that is contaminated by toxicants. For each $f$, the model is run for a timespan for 50 years and the values of 50 years are used. This timespan is chosen because all of the differential equations are then at equilibrium. Furthermore, for each scenario the population size, infection prevalence and spillover risk are being calculated using the following formulas: $$\text{Population size} = S_P + I_P + S_T + I_T$$
$$\text{Infection prevelance} = \frac {I_T}{\text{population size}} $$
$$\text{Spillover risk} = \frac {I_T}{f} $$

Coming back to the scenarios, in the first scenario three different $\beta_T$ values are being used: 

* $\beta_T$ < $\beta_P$
* $\beta_T$ = $\beta_P$
* $\beta_T$ > $\beta_P$

In the second scenario, two values $c_{\sigma}$ are being used:

* $c_{\sigma}$ = 0.2
* $c_{\sigma}$ = 0.8


## Results
```{r warning=FALSE}
## ODE FUNCTION


# Load deSolve package
library(deSolve)

# Function with the models differential equations
wildlife_urbanization_model <- function(t, state, parameters) {
  with(as.list(c(state, parameters)),{
    
    dSp <- (b0 - (b1 * (Sp + Ip)) /(1-f) ) * (Sp + Ip) - m * Sp -  # demography
      beta_p * Sp * Ip + gamma * Ip -  # infection
      sigma * f * Sp + sigma * (1 - c_sigma) * (1 - f) * St  # movement
    
    
    dIp <-  beta_p * Sp * Ip - gamma * Ip -  # infection
      (m + mu) * Ip -  # demography
      sigma * f * Ip + sigma * (1 - c_sigma) * (1 - f) * It  # movement
    
    
    dSt <- (b0 - (b1 * (St + It) / f)) * (St + It) - (m / (1 - c_m)) * St -  # demography
      beta_t * St * It + gamma * It +  # infection
      sigma * f * Sp - sigma * (1 - c_sigma) * (1 - f) * St  # movement
    
    
    dIt <- beta_t * St * It - gamma * It -  # infection
      ((m + mu) / (1 - alpha * c_m)) * It +  # demography
      sigma * f * Ip - sigma * (1 - c_sigma) * (1 - f) * It  # movement
      
      
    list(c(dSp, dIp, dSt, dIt))
  }) 
}

```


```{r}
## RUN MODEL FUNCTION

run_model <- function(population = 50000, infected = 100, m = 0.1, b0 = 0.4, 
                      c_m = 0.2, beta_p = 0.006, beta_t = 0.006, gamma = 36.5, 
                      mu = 0.25, alpha = 2, sigma = -log(0.1), c_sigma = 0.2){
  
  # Create a data frame to store needed data
  df <- data.frame(matrix(nrow = 0, ncol = 8))
  colnames(df) <- c('f', 'Sp', 'Ip', 'St', 'It', 'N', 'p', 'rho')
  
  for (f in seq(0.01, 0.99, 0.01)){
    # Calculate b1 based on the function parameters
    b1 <- (b0 - m) / population
    
    # Calculate infection status per habitat
    Sp <- (population - infected) * (1 - f)
    Ip <- infected * (1 - f)
    St <- (population - infected) * f
    It <- infected * f
    
    # Creating a vector with the parameter values
    parameters <- c(m = m, b0 = b0, b1 = b1, c_m = c_m, beta_p = beta_p, 
                    beta_t = beta_t, gamma = gamma, mu = mu, alpha = alpha, 
                    f = f, sigma = sigma, c_sigma = c_sigma)
  
    # Creating a vector with the initial values
    state<- c(Sp = Sp, Ip = Ip, St = St, It = It)
    
    # Time frame of 50 years
    times <- seq(0, 50, 0.05)
    
    out <- tail(ode(y = state, times = times, func = wildlife_urbanization_model, parms = parameters), 1)
    
    df[nrow(df) + 1,] <- c(f, out[2:5], sum(out[2:5]), (out[3] + out[5])/sum(out[2:5]), out[5]/f)
    }
  
  return(df)
}
```



```{r}
## FOR LOOPJES OBTAINING DATA
for (beta_t in c(0.0015, 0.006, 0.0105)){
  df <- run_model(beta_t = beta_t)
  if (beta_t == 0.0015){
    N_all <- data.frame('0.0015' = df$N)
    p_all <- data.frame('0.0015' = df$p)
    rho_all <- data.frame('0.0015' = df$rho)
  }
  if (beta_t == 0.006){
    N_all <- data.frame(N_all, '0.006' = df$N)
    p_all <- data.frame(p_all, '0.006' = df$p)
    rho_all <- data.frame(rho_all, '0.006' = df$rho)
  }
  if (beta_t == 0.0105){
    N_all <- data.frame(N_all, '0.0105' = df$N)
    p_all <- data.frame(p_all, '0.0105' = df$p)
    rho_all <- data.frame(rho_all, '0.0105' = df$rho)
  }
}
```

```{r}
## FOR LOOPJES VOOR PLOTTEN
datasets <- list(N_all, p_all, rho_all)
labels <- c('population size', 'infection prevealance', 'spillover risk')
cols <- c('orange', 'blue', 'purple')
for (item in 1:length(datasets)){
  data <- datasets[[item]]
  for (scenario in 1:3){
    if (scenario == 1){
      plot(data[,scenario] ~ df$f, col = cols[scenario], type = 'l', lwd = 3, ylim = c(0, max(data) * 1.25), xlab = 'f', ylab = labels[item])
    }
    else{
      lines(data[,scenario] ~ df$f, col = cols[scenario], lwd = 3)
    }
  }
}
```


```{r}

run_model_sensitivity <- function(population = 50000, infected = 100, m = 0.1, b0 = 0.4, 
                      c_m = 0.2, beta_p = 0.006, beta_t = 0.006, gamma = 36.5, 
                      mu = 0.25, alpha = 2, sigma = -log(0.1), c_sigma = 0.2, f = 0.1){
  
  # Create a data frame to store needed data
  df <- data.frame(matrix(nrow = 0, ncol = 2))
  colnames(df) <- c('mu', 'N')
  
  # Calculate b1 based on the function parameters
  b1 <- (b0 - m) / population
  
  # Calculate infection status per habitat
  Sp <- (population - infected) * (1 - f)
  Ip <- infected * (1 - f)
  St <- (population - infected) * f
  It <- infected * f
  
  # Creating a vector with the parameter values
  parameters <- c(m = m, b0 = b0, b1 = b1, c_m = c_m, beta_p = beta_p, 
                  beta_t = beta_t, gamma = gamma, mu = mu, alpha = alpha, 
                  f = f, sigma = sigma, c_sigma = c_sigma)

  # Creating a vector with the initial values
  state<- c(Sp = Sp, Ip = Ip, St = St, It = It)
  
  # Time frame of 50 years
  times <- seq(0, 50, 0.05)
  print(c_m)
  out <- tail(ode(y = state, times = times, func = wildlife_urbanization_model, parms = parameters), 1)
  
  df[nrow(df) + 1,] <- c(c_m, (out[3] + out[5])/sum(out[2:5]))
  
  return(df)
}

```

```{r}
df_mu <- data.frame(matrix(nrow=0, ncol=2))
for (mu in seq(0.05, 0.95, 0.02)){
  df_mu[nrow(df_mu) + 1,] <- run_model_sensitivity(c_m = mu)
}
plot(df_mu$X2 ~ df_mu$X1, type = 'l', ylim = c(0, 1))
```