---
title: ''
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    fig_caption: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Methods
In this section the methods will be discussed. This is divided into two parts: the software and the model. The software part lists the programming language and packages that have been used, with the corresponding versions. The model section lists the differential equations. This is followed by the values and definitions of each parameter of each value is then discussed. 

The code used in this project is written used R version 4.1.3. In R the DeSolve package (version 1.32) is imported in order to model the differential equations, which are shown below. 

The model is set-up using the following differential equations:
```{r, echo=FALSE, fig.cap="caption.....", out.width = '70%'}
knitr::include_graphics("./images/ODE.png")
```
In figure 1 four differential equations are shown. Firstly, $\frac {dS_P}{dt}$ calculates the population size of the susceptible (S) flying foxes which are located in a pristine (P) area. Secondly, $\frac {dI_P}{dt}$ calculates the mount of infected (I) flying foxes in a pristine (P) area. Thirdly, $\frac {dS_T}{dt}$ calculates the amount of flying foxes which are susceptible (S) and in a toxic (T) area. Lastly, $\frac {dI_T}{dt}$ calculates the population size of the flying foxes which are infected (I) and located in a toxic area (T)

Additionally, in figure 1 parts of the differential equations are coloured. Each colour represents a different process which may affect the population size with that infection status and habitat. Green is used to indicate demography, orange to indicate infection and purple to indicate movement.

Each equation is broken down into its parameters and listed below:
```{r, echo=FALSE, fig.cap="caption.....", out.width = '70%'}
knitr::include_graphics("./images/parameters.png")
```
As shown in figure 2;  $\beta_T$, $f$ and $\text{population size}$ show variable values. This is based on the different scenarios that are being modulated. In both scenarios (to be discussed shortly) $f$ is being changed, ranging from 0.01 to 0.99 (in steps of 0.01). This is the  amount of landscape that is contaminated by toxicants. For each $f$, the model is run for a timespan of 50 years and the last values are used. This timespan is chosen because all of the differential equations are then at equilibrium. Furthermore, for each scenario the population size, infection prevalence and spillover risk are being calculated using the following formulas: $$\text{Population size} = S_P + I_P + S_T + I_T$$
$$\text{Infection prevelance} = \frac {I_T}{\text{population size}} $$
$$\text{Spillover risk} = \frac {I_T}{f} $$

Coming back to the scenarios, in the first scenario $\beta_T$ is being varied. This is done to simulate the effect of different transmission rates in a toxic contaminated habitat with respect to the transmission rate in a pristine habitat. Three different $\beta_T$ values were used to obtain the following scenarios: *ander woord voor scenarios kiezen*

* $\beta_T < \beta_P$
* $\beta_T = \beta_P$
* $\beta_T > \beta_P$

In the second scenario, the population size is being varied. This is done to see what the effect is of the population size when also the fraction of the toxic-contaminated habitat is changed. The following population sizes were used:

* $\text{population size} = ...$


## Results

As mentioned earlier, two scenarios have been modulated. This section is divided according to these scenarios.

```{r warning=FALSE}
## ODE FUNCTION

# Load deSolve package
library(deSolve)

# Function with the models differential equations
wildlife_urbanization_model <- function(t, state, parameters) {
  with(as.list(c(state, parameters)),{
    
    dSp <- (b0 - (b1 * (Sp + Ip)) /(1-f) ) * (Sp + Ip) - m * Sp -  # demography
      beta_p * Sp * Ip + gamma * Ip -  # infection
      sigma * f * Sp + sigma * (1 - c_sigma) * (1 - f) * St  # movement
    
    
    dIp <-  beta_p * Sp * Ip - gamma * Ip -  # infection
      (m + mu) * Ip -  # demography
      sigma * f * Ip + sigma * (1 - c_sigma) * (1 - f) * It  # movement
    
    
    dSt <- (b0 - (b1 * (St + It) / f)) * (St + It) - (m / (1 - c_m)) * St -  # demography
      beta_t * St * It + gamma * It +  # infection
      sigma * f * Sp - sigma * (1 - c_sigma) * (1 - f) * St  # movement
    
    
    dIt <- beta_t * St * It - gamma * It -  # infection
      ((m + mu) / (1 - alpha * c_m)) * It +  # demography
      sigma * f * Ip - sigma * (1 - c_sigma) * (1 - f) * It  # movement
      
      
    list(c(dSp, dIp, dSt, dIt))
  }) 
}

```

```{r}
## MODEL FUNCTION

run_model <- function(population = 50000, infected = 100, m = 0.1, b0 = 0.4, 
                      c_m = 0.2, beta_p = 0.006, beta_t = 0.006, gamma = 36.5, 
                      mu = 0.25, alpha = 2, sigma = -log(0.1), c_sigma = 0.2){
  
  # Create a data frame to store needed data
  df <- data.frame(matrix(nrow = 0, ncol = 8))
  colnames(df) <- c('f', 'Sp', 'Ip', 'St', 'It', 'N', 'p', 'rho')
  
  for (f in seq(0.01, 0.99, 0.01)){
    # Calculate b1 based on the function parameters
    b1 <- (b0 - m) / population
    
    # Calculate infection status per habitat
    Sp <- (population - infected) * (1 - f)
    Ip <- infected * (1 - f)
    St <- (population - infected) * f
    It <- infected * f
    
    # Creating a vector with the parameter values
    parameters <- c(m = m, b0 = b0, b1 = b1, c_m = c_m, beta_p = beta_p, 
                    beta_t = beta_t, gamma = gamma, mu = mu, alpha = alpha, 
                    f = f, sigma = sigma, c_sigma = c_sigma)
  
    # Creating a vector with the initial values
    state<- c(Sp = Sp, Ip = Ip, St = St, It = It)
    
    # Time frame of 50 years
    times <- seq(0, 50, 0.05)
    
    out <- tail(ode(y = state, times = times, func = wildlife_urbanization_model, parms = parameters), 1)
    
    df[nrow(df) + 1,] <- c(f, out[2:5], sum(out[2:5]), (out[3] + out[5])/sum(out[2:5]), out[5]/f)
    }
  
  return(df)
}
```

```{r}
## PLOT FUNCTION
plot_scenario <- function(datasets, y_labels, line_cols, legends){
  plot_labels = c("A", "B", "C")
  for (item in 1:length(datasets)){
    data <- datasets[[item]]
    for (scenario in 1:3){
      if (scenario == 1){
        plot(data[,scenario] ~ df$f, col = line_cols[scenario], 
             type = 'l', lwd = 3, ylim = c(0, max(data) * 1.25),
             xlab = 'f', ylab = y_labels[item], las = 1)
        text(x=0.05, y=max(data) * 1.2, labels = plot_labels[item], font = 2)
      }
      else{
        lines(data[,scenario] ~ df$f, col = line_cols[scenario], lwd = 3)
      }
    }
  }
}
```

### Scenario 1: beta_t

```{r}
## FOR LOOPJES OBTAINING DATA

for (beta_t in c(0.0015, 0.006, 0.0105)){
  df <- run_model(beta_t = beta_t)
  if (beta_t == 0.0015){
    N_all <- data.frame('0.0015' = df$N)
    p_all <- data.frame('0.0015' = df$p)
    rho_all <- data.frame('0.0015' = df$rho)
  }
  if (beta_t == 0.006){
    N_all <- data.frame(N_all, '0.006' = df$N)
    p_all <- data.frame(p_all, '0.006' = df$p)
    rho_all <- data.frame(rho_all, '0.006' = df$rho)
  }
  if (beta_t == 0.0105){
    N_all <- data.frame(N_all, '0.0105' = df$N)
    p_all <- data.frame(p_all, '0.0105' = df$p)
    rho_all <- data.frame(rho_all, '0.0105' = df$rho)
  }
}
```

```{r, fig.cap = 'beta_t scenarios', fig.width=7}
beta_t_data <- list(N_all, p_all, rho_all)
beta_t_labels <- c('population size', 'infection prevealance', 'spillover risk')
beta_t_cols <- c('orange', 'blue', 'purple')
beta_t_legends <- c(expression(paste(beta[T], " < ", beta[P])),expression(paste(beta[T], " = ", beta[P])),
                    expression(paste(beta[T], " > ", beta[P])))
par(mfrow=c(2,2))
plot_scenario(datasets = beta_t_data, y_labels = beta_t_labels, line_cols = beta_t_cols, 
              legends = beta_t_legends)
legend(1.05, 28000, legend = beta_t_legends, fill = beta_t_cols, xpd=NA)
```
In figure # the population size, infection prevalence and spillover risk are shown with varying $\beta_t$ values. 

In figure #A \textcolor{blue}{$\beta_t = \beta_p$} and \textcolor{violet}{$\beta_t > \beta_p$} show a similar trend. When the fraction of contaminant habitat increases ($f$), the population size first increases ($f$ < 0.15) a little and then declines slowly ($f$ > 0.15). However, the population size of $\beta_t = \beta_p$ has a higher increase until it declines resulting in a higher population size at different $f$'s. Interestingly, when looking at $\beta_t < \beta_p$ an increase can be seen until an $f$ of 0.7 is reached, which is way higher when compared to the other scenarios where it increased until 0.15. After an $f$ of 0.7 it declines.

In figure #B $\beta_t = \beta_p$ and $\beta_t > \beta_p$ are again very similar. A slow decline of infection prevalence can be seen until an %f% of approximately 0.65 is reached, after which it increases. Furthermore, $\beta_t < \beta_p$ shows a steeper and longer decrease as $f$ increases. It then increases in the same way as$\beta_t = \beta_p$ and $\beta_t > \beta_p$.

In figure #C $\beta_t = \beta_p$ and $\beta_t > \beta_p$ repeatedly show similar trends. They both have a sharp S-shaped increase with respect to an increasing value of $f$. Hereafter it declines. The same S-shaped increase can be seen when looking at $\beta_t < \beta_p$. However, this increases is less steap and the optimum is reached at a higher $f$. Furthermore, when the optimum is reached it does not decline at all.

Altogether it seems like a similar trend in all graphs can be seen. $\beta_t = \beta_p$ and $\beta_t > \beta_p$ show very similar curves, where $\beta_t = \beta_p$ is delayed or more spread out. When looking at  $\beta_t < \beta_p$ the same phenomenon can be seen, but more extreme. The increases and decreases are less steep and take longer with respect to an increasing $f$.



### Scenario 2: population size

```{r}
## FOR LOOPJES OBTAINING DATA

# for (population_size in c(1000, 50000, 100000)){
#   df <- run_model(beta_t = 0.0015, population = population_size)
#   if (population_size == 1000){
#     N_all <- data.frame('25000' = df$N)
#     p_all <- data.frame('25000' = df$p)
#     rho_all <- data.frame('25000' = df$rho)
#   }
#   if (population_size == 50000){
#     N_all <- data.frame(N_all, '50000' = df$N)
#     p_all <- data.frame(p_all, '50000' = df$p)
#     rho_all <- data.frame(rho_all, '50000' = df$rho)
#   }
#   if (population_size == 100000){
#     N_all <- data.frame(N_all, '75000' = df$N)
#     p_all <- data.frame(p_all, '75000' = df$p)
#     rho_all <- data.frame(rho_all, '75000' = df$rho)
#   }
# }
```

```{r}
# population_data <- list(N_all, p_all, rho_all)
# population_labels <- c('population size', 'infection prevealance', 'spillover risk')
# population_cols <- c('orange', 'blue', 'purple')
# 
# plot_scenario(datasets = population_data, y_labels = population_labels, line_cols = population_cols)
```
















































```{r}
# 
# run_model_sensitivity <- function(population = 50000, infected = 100, m = 0.1, b0 = 0.4, 
#                       c_m = 0.2, beta_p = 0.006, beta_t = 0.006, gamma = 36.5, 
#                       mu = 0.25, alpha = 2, sigma = -log(0.1), c_sigma = 0.2, f = 0.1){
#   
#   # Create a data frame to store needed data
#   df <- data.frame(matrix(nrow = 0, ncol = 2))
#   colnames(df) <- c('mu', 'N')
#   
#   # Calculate b1 based on the function parameters
#   b1 <- (b0 - m) / population
#   
#   # Calculate infection status per habitat
#   Sp <- (population - infected) * (1 - f)
#   Ip <- infected * (1 - f)
#   St <- (population - infected) * f
#   It <- infected * f
#   
#   # Creating a vector with the parameter values
#   parameters <- c(m = m, b0 = b0, b1 = b1, c_m = c_m, beta_p = beta_p, 
#                   beta_t = beta_t, gamma = gamma, mu = mu, alpha = alpha, 
#                   f = f, sigma = sigma, c_sigma = c_sigma)
# 
#   # Creating a vector with the initial values
#   state<- c(Sp = Sp, Ip = Ip, St = St, It = It)
#   
#   # Time frame of 50 years
#   times <- seq(0, 50, 0.05)
#   print(c_m)
#   out <- tail(ode(y = state, times = times, func = wildlife_urbanization_model, parms = parameters), 1)
#   
#   df[nrow(df) + 1,] <- c(c_m, (out[3] + out[5])/sum(out[2:5]))
#   
#   return(df)
# }

```

```{r}
# df_mu <- data.frame(matrix(nrow=0, ncol=2))
# for (mu in seq(0.05, 0.95, 0.02)){
#   df_mu[nrow(df_mu) + 1,] <- run_model_sensitivity(c_m = mu)
# }
# plot(df_mu$X2 ~ df_mu$X1, type = 'l', ylim = c(0, 1))
```